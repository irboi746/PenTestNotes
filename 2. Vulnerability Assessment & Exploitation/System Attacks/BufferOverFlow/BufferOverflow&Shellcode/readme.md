# Table of Content
- [Buffer Overflow](#buffer-overflow)
  * [Finding BOF](#finding-bof)
  * [Buffer Overflow Prevention](#buffer-overflow-prevention)
- [Shellcoding](#shellcoding)
    + [Types of Shellcode](#types-of-shellcode)
    + [Creating & Debugging](#creating---debugging)
    + [Shellcode Encoding](#shellcode-encoding)
    + [Creating More Advanced Shellcode](#creating-more-advanced-shellcode)
 
# Buffer Overflow
* Buffer refers to any area in memory where more than one piece of data is stored.
* Overflow occurs when we try to fill more data than the buffer can handle.
* Buffer Overflow is when a condition in a program where a function attempts to copy more data into a buffer than it can hold and the overflow writes into memory space that is not allocated to it.  

## Example 1
   ![BOF_eg1](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image25.png)
   * Over here `strcopy` tries to copy 35 “A”s into a variable buffer which will only accept 10 characters. 
   * The extra “A”s will be written into the memory beyond the stack frame and buffer overflow occurs. 
   * Program will crash and “strcpy” is the vulnerable function. 
   ![BOF_eg1](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image9.png)
   * Above is a visualisation in the stack frame. On the right, We can see that main() is loaded into the stack frame and function is loaded on top of the main(). 
   * When 35 ”A”s is copied into the stack, it overwrites the bottom of the stack.
   * An attacker can exploit this by overwriting the EIP with a payload to return the function to a specific memory address location.
   * **Resolution** : use `strncpy` which checks for bounds and copies only until the size that the variable can accept.

## Example 2
   ![BOF_eg2](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image6.png)
   ![BOF_eg2](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image5.png)
   ![BOF_eg2](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image39.png)
   ![BOF_eg2](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image43.png)
   * The condition for `good_password()` to activate will be when `password = 1`.
   ![BOF_eg2](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image45.png)
   * When an input like the above is supplied as an argument for the main function, BOF will occur as strcpy() in the bf_overflow() function is vulnerable to it. \
   ![BOF_eg2](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image14.png)
   * The program will crash with the following error code.
   * From the error code, we can see that the program tried to access the location pointed to 0x41414141 which is the hexadecimal value of “A”. 
   * This means that EIP is overwritten with the input that caused a BOF and the program tries to run the overwritten EIP but crashes the program. 
   * Exploitation : 
      * The idea here would be to cause a buffer overflow but instead of crashing the program, we point the EIP to run the good_password() function.
      * To be able to do this, we will need to know specifically the minimum number of “A”s required to cause it. 
   * Steps to exploit Example 2 code : 
      1. Find address of vulnerable function to exploit
      2. Find the exact BOF point by adding one byte to input until the program crashes. It will be due to BOF. 
      3. Check for stack smashing
      4. Replace last 4 bytes with address of function to run.
    
     * Step 1 : Find address of Vulnerable Function to exploit
       ![BOF_eg2](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image41.png)
       ![BOF_eg2](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image29.png)
       * Using objdump, we will be able to dump out the disassembly of the program. As can be seen above, the address of the function in the stack of `good_password()` is 00401548.
     * Step 2 : Find the exact BOF point
       * Now that we know the stack address of `good_password()`, we will now attempt to find out how many characters will cause the BOF. This is done by manually adding characters into the input as seen below. 
       ![BOF_eg2](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image26.png)
       * “ABCD” is used as the 4 characters to be input as when BOF is encountered, we will be able to see how many bytes more we need to input to get the full 8 bytes into the EIP. As addresses are 8 bytes long. 
       * Program crashes after 18 Char (see below)
       ![BOF_eg2](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image57.png)
       
     * Step 3 : Check for Stack Smashing
       * As can be seen below, there is a BOF happening, but error shown is not “ABCD” in hex 41,42,43,44 respectively. Hence more “A”s will be added so that we can push all 8 bytes of “ABCD” into the stack. 
       ![BOF_eg2](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image11.png)
       * Expected outcome where EIP is replaced \
       ![BOF_eg2](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image23.png)

     * Step 4 : Replace last 4 bytes with address of function to run
       *  In the python script below, what is done is to write into variable payload 22 “A”s in hex and then append the address of `good_password()` to the variable `payload` and run the executable with the argument. 
       ![BOF_eg2](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image55.png)
       *  This is done with python as we can directly enter hex into the cli through `os.system()` but if we were to do it in the cli manually, we will need to key payload in the ASCII and not hex. 
       *  Successful Outcome of BOF: \
       ![BOF_eg2](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image52.png)
       * Program might or might not crash after the execution as the action above, might have damaged other registers or data on the stack which might be important for the program to function normally. 
       * However, at this stage, the job is done as the backdoor is open, what the target application does is not a concern. 

## Finding BOF
   * BOF can be triggered by : 
     1. user input overflow
     2. data loaded from the disk
     3. data from the network

   * Functions below are vulnerable to BOF: 
     * does not properly validate inputs before operating 
     * does not check input boundaries

   * BOF is a problem of programming languages which allows the use of pointers or provide raw access to memory
   * Hence interpreted languages like C#, and Java are safe from BOF
   * Tools that can help : 
     * If source code is available : 
       * [Splint](http://splint.org/)
       * [Cppcheck](https://cppcheck.sourceforge.io/)
     * Source code not available : 
       * Debugger
       * Fuzzer/Tracer
       * [Peach Fuzzing Platform](https://about.gitlab.com/solutions/dev-sec-ops/)
       * [Sulley](https://github.com/OpenRCE/sulley)
       * [Sfuzz](https://github.com/orgcandman/Simple-Fuzzer)
       * [FileFuzz](https://packetstormsecurity.com/files/39626/FileFuzz.zip.html)

   * Almost 50% of vulnerabilities are un-exploitable but they are still susceptible to DOS or cause other side effects. 

## Buffer Overflow Prevention
### Address Space Layout Randomisation
   * to introduce randomness for executables, libraries and stacks in the memory address space
   * by loading executables at different memory locations every time 
   * to make it more difficult for an attacker to predict memory addresses and cause exploits to fail and crash.
   * However, ASLR is not enabled for all modules and even if a process has ASLR enabled, there could be a DLL in the address space without ASLR and this would make the process vulnerable to ASLR bypass attack. 

### EMET (Enhanced Mitigation Experience Toolkit)
   * a tool provided by Windows to deploy security mitigation technologies to all applications. 

### Data Execution Prevention
   * is a hardware and software measure that prevents execution of code from pages in memory that are not explicitly marked as executable. 
   * As injected code cannot be run from the region, buffer overflow exploits will not be able to execute easily. 

### Stack Cookies (Canary)
   * a security implementation that places a random integer just before the stack return pointer.
   * As BOF usually overwrites memory from lower to higher addresses, it will overwrite the canary value along with the ESP. 
   * The canary value will be checked to make sure it is not changed before a routine uses the ESP. 

# Shellcoding
### Types of Shellcode
1. Remote Shellcode (Remote BOF)
   * shellcode sent through the network along with an exploit. (i.e shellcode injection/remote code execution)
   * goal is to provide remote access to exploited machines over the network
   * sub-divided into 3 types of shellcodes
     1. Connect back : initiates connection back to attacker machine
     2. Bind Shell : binds a shell to a certain port on which an attacker can connect
     3. Socket Reuse : establishes a connection to a vulnerable process that does not close before the shellcode is run. The shellcode can then re-use the connection to communicate with the attacker. 

2. Local Shellcode
   * used to exploit local processes in order to get higher privileges on the machine (i.e privilege escalation shellcodes)

3. Staged Shellcode
   * used to exploit local processes in order to get higher privileges on the machine (i.e privilege escalation shellcodes) Staged Shellcode
   * used when shellcode size is bigger than the space that can be injected.
   * In this case, a small shellcode will be injected and executed (stage 1)  which will fetch the larger shellcode (stage 2) into the process memory and execute it. 
   * Staged Shellcode is divided into two sub types : 
     1. Egg-Hunt Shellcode
       * when larger shellcode can be injected, but it is unknown where in the process this shellcode will be actually injected. 
       * hence a small shellcode (egghunter) will search for the bigger shellcode (egg) within the process address space amd execute the big shellcode  
     2. Omelet Shellcode
       * similar in operation where small shellcode will search and execute another shellcode in the address space, but instead of a large shellcode, many small shellcodes are combined and executed instead. 
       * this is to avoid shellcode detectors. 

4. Download and Execute Shellcode
   *  this shellcode will download an executable from the internet and execute it. 

### Creating & Debugging
#### Debug Function
* Below is a C code snippet used to debug shellcodes. \
![Shellcode_dbg](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image42.png)

#### Steps to Creating Shellcode : 
  1. Figure out a Goal of the Shellcode
  2. Find out the Function needed
  3. Obtain the address of the Function needed
  4. Find out the Parameters and registers used by the shellcode
  5. Write ASM code based on the above. 
  6. Compile ASM code
  7. Disassemble the assembled shellcode
  8. copy the byte code
  9. test shellcode with the C code snippet above. 

#### Example 
  1. Figure out a Goal of the Shellcode
     * Create a shellcode that cause the thread to sleep for 5 seconds 
     
  2. Find out the Function needed
     * `Sleep` in ***Kernel32.dll***
     
  3. Obtain the address of the Function needed
     * Open ***Kernel32.dll*** in Immunity Debugger Right click on disassemble panel 
     * select `Search For` > `Name in all modules`. Search for "sleep" \
     ![CreateShellcode](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image56.png)
     * Look for “sleep” that is within the `.text` region and from the above picture, we can see that it is at the address `0x757D82D0`
     
  4. Find out the Parameters and registers used by the shellcode \
     ![CreateShellcode2](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image49.png)
     * From the above we can see that sleep requires 1 parameters and that is a dwMilliseconds.
     
  5. Write ASM code based on the above. \
     ![CreateShellcode3](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image54.png)
     * our code will be as above. `EAX` will be the register that will be storing the parameter, then we store the address of “sleep” into `EBX`. Then we do a call `EBX` which will call the address at `EBX`.
 
  6. Compile ASM code \
     ![CreateShellcode4](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image30.png)
     
  7. Disassemble the assembled shellcode
     * Dump out the byte code using objdump \
     ![CreateShellcode5](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image15.png)
  
  8. copy the byte code
     * then we will need to copy this byte code which is out shellcode. \
     * This is a useful [command to use](https://www.commandlinefu.com/commands/browse) 

  9. test shellcode with the C code snippet above. \
     ![CreateShellcode5](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image1.png)
  
### Shellcode Encoding
   * Most BOF vulnerabilities have some form of restrictions over the data which is overflowed. 
   * Therefore, encoding is required to make sure that the exploit can work as expected. 
   * There are two types of encoding and they are **NULL FREE ENCODING** and **ALPHANUMERIC ENCODING**
     1. Null Free Encoding
        * C language string functions work till a NULL or 0 byte is found. 
        * Therefore if shellcode contains null character it will fail. 
        * Hence the idea of null encoding is to replace machine instructions that contain zeroes to instructions that do not contain zeroes but achieve the same result. 
        ![Shellcoding1](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image21.png)
     2. Alphanumeric Encoding
        *  Sometimes the target process filters out all non-alphanumeric bytes from data. Hence there is a need for all alpha-numeric shellcodes.
        *  SMC (Self-Modifying Code) is used to achieve this. 
        *  encoded shellcode is prepended with a decoder stub that has to be valid alphanumeric shellcode, which on execution will decode the shellcode which is in alphanumeric format to its original format and executed.   

### Creating More Advanced Shellcode
* shellcoding requires a good understanding of the target operating system. 
* To write a windows shellcode that spawn a command prompt will require the study of the function that can spawn the command prompt. 

 
