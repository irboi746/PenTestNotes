  # Architecture Fundamentals
  ## Table of Content
  * [CPU](#cpu)
  * [Registers](#registers)
  * [Process Memory](#process-memory)
  * [Stack](#stack)
  * [Procedures and Functions](#procedures-and-functions)
  * [Stack Frames](#stack-frames)
  * [Stacks and Processes](#stacks-and-processes)
  * [Endianness](#endianness)
  * [NOPs](#nops)
  ### CPU
  * the device in charge of executing machine code of a program
  * machine code is a set of instruction that the CPU will process 
  * each instruction is primitive commands to move data, change the flow of execution, perform arithmetic, or logic operations
  * These instructions are represented in HEX hence ASM is the translation to human readable language.
  * NASM (Netwide Assembler) and MASM (Microsoft Macro Assembler) are two most popular Assemblers. 
  ![machineVSassembly](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image2.png)
  * ISA(Instruction Set Architecture) is different for different CPUs
  * Most common ISA is the x86 (32-bit) and x86_64 (64-bit)
  * For this course, the General Purpose Register (GPR) will be the focus

  ### Registers
  * There are 8 General Purpose Registers (GPR) within CPU
  * Different GPRs have their own purpose as below : \
  ![GPR_Purpose](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/8GPR%26Purpose.JPG)
  * These 8 GPRs each have their annotations from 8bit to 64bits
  ![GPR_Annotation](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image27.png) 
  
  ### Process Memory
  ![ProcMem](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image31.png)
  * above is the structure of a process when it is running in the memory.
  * It is divided into 4 regions : .text, .data, heap and stack. 
     * .text : also known as the instruction segment; it contains program code and is marked as read-only

     * .data : divided into initialised and uninitialised data. Initialised data are data such as static and global declared variables whereas uninitialised data (BSS - Block Started by Symbol) are variables that are initialised to zero or variables that do not have explicit initialisation (e.g static int t)

     * heap : a pile of memory available to programmers to allocate and deallocate during execution of instructions through brk and sbrk syscall which is used by malloc, alloc and free. 

     * stack : LIFO block of memory, located in the higher part of the memory. It can be thought of as an array used to save a function's return addresses, to pass function arguments and store local variables.
  
   ### Stack
   * ESP is the register that will identify the top of the stack and PUSH and POP instructions will modify the ESP. 
   * The stack grows downwards towards lower memory address
   * As can be seen in the above illustration, Heap would start from lower addresses and grow upwards while the stack would start from the end of the memory and grow downwards.
   
   #### Push Instruction
   * When a PUSH instruction is executed, ESP will be subtracted with 4(32-bit) or 8 (64-bit) and the data will be written into ESP and ESP will be updated to the address at the top of the stack. \
   ![Push_Ins](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image4.png)
   #### Pop Instruction
   * when a POP instruction is executed ESP will be added with 4 (32-bit) or 8 (64-bit). The data contained at the address that is popped is retrieved and stored \
   ![Pop_Ins](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image40.png)

   * `As can be seen above, the value popped from the stack is not deleted (zeroed). It will stay in the stack until another instruction overwrites it.`

   ### Procedures and Functions
   * A procedure is used to perform certain task in order, while a function is used to calculate results using given inputs. 
   * Functions contain two important components: the **prologue** and **epilogue**. 
   * Prologue prepares the stack to be used, while the epilogue resets the stack to the prologue settings. 
   * Prologue \
   ![prologue](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image34.png)
   * Epilogue \
   ![epilogue1](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image18.png)
   ![epilogue2](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image53.png)
   * From the first line, we can see that the address of the current EBP is moved into ESP. Hence, ESP is pointing at EBP which is also the top of the stack for the previous execution.
   * The address of the EBP of the previous execution is then popped into EBP and hence we return back to the previous stack frame \
   <code><img height="200" src="https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image19.png"></code>
   <code><img height="200" src="https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image8.png"></code>
   <code><img height="200" src="https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image37.png"></code>
   * The series of pictures above shows the concrpt of **epiologue**
   
   ### Stack Frames
   * The stack consists of logical stack frames (portions/areas of the Stack) that are pushed when calling a function and popped when returning a value. 
   * When a subroutine (function/procedure) is started, a stack frame is created and assigned to the top of the stack.
   * When the subroutine ends, the program : 
      * receives the parameters passed from the routine 
      * the EIP is reset to the location at the time of the initial call
   * From below, we will be able to see that a stack frame is delimited by EBP and ESP
   * A process has three main operations: 
      * Function call : arguments in brackets needs to be evaluated
      * control flow jumps to the body of the function and program executes code
      * Once the function ends, return statement is encountered , the program returns to the function call. 
  
   ### Stacks and Processes
   #### Example 1
   ![Stack&Process1](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image46.png)
   ![Stack&Process2](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image16.png)
   * The two pictures above are part of an example of a function call.
   * As can be seen from the code above, main() is the entry point and it will be the first stack frame created and pushed into the stack.
   * Then within the main(), the first instruction executed is a call to the function a(). A stack frame for a() will be created and pushed on top of the stack. 
   * The stack pointer will also be moved to point to the top of the stack which is where a() is. 
   * Likewise, within a() is another function b() and a new stack frame for b() is created and pushed on top of the stack.
   * Subsequently, function b() will do its operations and return and the stack pointer will move to its previous location a().
   * likewise for a(), when it returns, it will move the stack pointer to the previous location which is main().
   #### Example 2
   ![Stack&Process3](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image13.png)
   1.  When the program above starts, the function parameters from main (int argc, char *argv) will be pushed on the stack.
   2. A CALL instruction for the function main(int argc, char *argv) will be issued and the processor will push the EIP of the current process to the stack and EIP will be loaded with the destination address of main(int argc, char argv*). Control will be passed to main().
   3. Now that main() is running, a new stack frame will be created. To do that we will have to save the current EBP (base pointer) into the stack so as to not the current execution - the old stack frame. As such a prologue will be executed. 
   4. Once prologue ends, local variables will be copied into the stack. Variables cannot be pushed into the stack as the ESP is currently pointing at the top of the stack which is not within the stack frame. Therefore, the instruction to fill local variables is as such : 
   ![Stack&Process4](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image47.png)
   5. In the above example, hex 0B (dec 11) is moved into memory address of location pointed at ESP+Y
   6. Within main(), functest() is called and the process of creating a stack frame and filling local variables will be repeated again. 
   ![Stack&Process4](https://github.com/irboi746/eCPPTv2-notes/blob/main/images/SystemSec/image19.png)
   7. When the function is completed and a return statement is hit or when the program leaves subroutine, the epilogue will be executed. 
### Endianness
* Way of representing values in memory
* Focus : Big and Little Endian
    * Little Endian : read from low memory to high memory
    * Big Endian : start reading for high memory to low memory
### NOPs
* An assembly instruction that does nothing. 
* When NOP is encountered, CPU will skip to next instruction
* NOP is represented as `0x90` in hex in intel x86 CPUs.
* **NOP-sled technique** is used during BOF where NOPs are used to fill a portion of the stack so that payload can be inserted into the instruction where we want it to be executed. 
